robustness (computer science) see also faulttolerant computer system complex systems topics emergenceemergence selforganizationcollective consciousness collective behavioursocial dynamics collective intelligence collective action selforganized criticality herd mentality phase transition agentbased modelling synchronization ant colony optimization particle swarm optimization swarm behaviour networksscalefree networks social network analysis smallworld networks community identification centrality motifs graph theory scaling robustness systems biology dynamic networks adaptive networks evolution and adaptationartificial neural networks evolutionary computation genetic algorithms genetic programming artificial life machine learning evolutionary developmental biology artificial intelligence evolutionary robotics evolvability pattern formationspatial fractals reactiondiffusion systems partial differential equations dissipative structures percolation cellular automata spatial ecology selfreplication spatial evolutionary biology geomorphology systems theoryhomeostasis operationalization feedback selfreference goaloriented system dynamics sensemaking entropy cybernetics autopoiesis information theory computation theory complexity measurement nonlinear dynamicstime series analysis ordinary differential equations iterative maps phase space attractors stability analysis population dynamics chaos multistability bifurcation coupled map lattices game theoryprisoners dilemma rational choice theory bounded rationality irrational behaviour evolutionary game theory vte in computer science robustness is the ability of a computer system to cope with errors during execution introduction in general building robust systems that encompass every point of possible failure is difficult because of the vast quantity of possible inputs and input combinations for example imagine inputting some integer values some selected inputs might consist of a negative number zero and a positive number when using these numbers to test software in this way the developer generalizes the set of all reals into three numbers this is a more efficient and manageable method but more prone to failure generalizing test cases is an example of just one technique to deal with failurespecifically failure due to invalid user input systems generally may also fail due to other reasons as well such as disconnecting from a network regardless complex systems should still handle any errors encountered gracefully there are many examples of such successful systems some of the most robust systems are evolvable and can be easily adapted to new situations challenges programs and software are tools focused on a very specific task and thus arent generalized and flexible many organs are redundant in humans the kidney is one such example humans generally only need one kidney but having a second kidney allows room for failure this same principle may be taken to apply to software but there are some challenges when applying the principle of redundancy to computer science blindly adding code is not suggested blindly adding code introduces more errors makes the system more complex and renders it harder to understand this means more logic needs to be added to the system but as a system adds more logic components and increases in size it becomes more complex thus when making a more redundant system the system also becomes more complex and developers must consider balancing redundancy with complexity currently computer science practices do not focus on building robust systems areas robust programming robust programming is a style of programming that focuses on handling unexpected termination and unexpected actions it requires code to handle these terminations and actions gracefully by displaying accurate and unambiguous error messages these error messages allow the user to more easily debug the program principles paranoia when building software the programmer assumes users are out to break their code stupidity the programmer assumes users will try incorrect bogus and malformed inputs as a consequence the programmer returns to the user an unambiguous intuitive error message that does not require looking up error codes the error message should try to be as accurate as possible without being misleading to the user so that the problem can be fixed with ease dangerous implements users should not gain access to libraries data structures or pointers to data structures this information should be hidden from the user so that the user doesnt accidentally modify them and introduce a bug in the code when such interfaces are correctly built users use them without finding loopholes to modify the interface the interface should already be correctly implemented so the user does not need to make modifications the user therefore focuses solely on his or her own code cant happen very often code is modified and may introduce a possibility that an impossible case occurs impossible cases are therefore assumed to be highly unlikely instead the developer thinks about how to handle the case that is highly unlikely and implements the handling accordingly robust machine learning robust machine learning typically refers to the robustness of machine learning algorithms for a machine learning algorithm to be considered robust either the testing error has to be consistent with the training error or the performance is stable after adding some noise to the dataset robust network design robust network design is the study of network design in the face of variable or uncertain demands in a sense robustness in network design is broad just like robustness in software design because of the vast possibilities of changes or inputs robust algorithms there exists algorithms that tolerate errors in the input defensive programming nonfunctional requirement vtecomplex systemsbackground emergence selforganization collective behaviour social dynamics collective intelligence collective action collective consciousness selforganized criticality herd mentality phase transition agentbased modelling synchronization ant colony optimization particle swarm optimization swarm behaviour evolution adaptation artificial neural networks evolutionary computation genetic algorithms genetic programming artificial life machine learning evolutionary developmental biology artificial intelligence evolutionary robotics evolvability game theory prisoners dilemma rational choice theory bounded rationality irrational behaviour evolutionary game theory networks social network analysis smallworld networks community identification centrality motifs graph theory scaling robustness systems biology dynamic networks adaptive networks nonlinear dynamics time series analysis ordinary differential equations iterative maps phase space attractors stability analysis population dynamics chaos multistability bifurcation coupled map lattices pattern formation spatial fractals reactiondiffusion systems partial differential equations dissipative structures percolation cellular automata spatial ecology selfreplication spatial evolutionary biology geomorphology systems theory homeostasis operationalization feedback selfreference goaloriented system dynamics sensemaking entropy cybernetics autopoiesis information theory computation theory complexity measurement 