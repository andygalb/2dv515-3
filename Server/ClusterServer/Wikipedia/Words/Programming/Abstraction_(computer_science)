abstraction (computer science) mwparseroutput quoteboxbackgroundcolorf9f9f9border1px solid aaaboxsizingborderboxpadding10pxfontsize88mwparseroutput quoteboxfloatleftmargin05em 14em 08em 0mwparseroutput quoteboxfloatrightmargin05em 0 08em 14emmwparseroutput quoteboxcenteredmargin05em auto 08em automwparseroutput quoteboxfloatleft pmwparseroutput quoteboxfloatright pfontstyleinheritmwparseroutput quoteboxtitlebackgroundcolorf9f9f9textaligncenterfontsizelargerfontweightboldmwparseroutput quoteboxquotequotedbeforefontfamilytimes new romanseriffontweightboldfontsizelargecolorgraycontent verticalalign45lineheight0mwparseroutput quoteboxquotequotedafterfontfamilytimes new romanseriffontweightboldfontsizelargecolorgraycontent lineheight0mwparseroutput quotebox leftalignedtextalignleftmwparseroutput quotebox rightalignedtextalignrightmwparseroutput quotebox centeralignedtextaligncentermwparseroutput quotebox citedisplayblockfontstylenormalmedia screen and maxwidth360pxmwparseroutput quoteboxminwidth100margin0 0 08emimportantfloatnoneimportant the essence of abstractions is preserving information that is relevant in a given context and forgetting information that is irrelevant in that context john v guttag in software engineering and computer science abstraction is the process of removing physical spatial or temporal details it is also very similar in nature to the process of generalization the abstract conceptobjects which are created by keeping common features or attributes to various concrete objects or systems of study the result of the process of abstraction abstraction in general is a fundamental concept to computer science and software development models can also be considered types of abstractions per their generalization of aspects of reality abstraction in computer science is also closely related to abstraction in mathematics due to their common focus on building abstractions as objects abstractions may also refer to vehicles features or rules of computational systems or programming languages that carry or utilize features of or abstraction itself such as the process or feature of using data types to perform data abstraction to decouple usage of from working representations of data structures within programs the concept of procedures functions or subroutines which represent a specific way of abstracting of control flow in programs the rules commonly named abstraction that generalize expressions using free and bound variables in the various versions of the lambda calculus the usage of sexpressions as an abstraction of data structures and programs in the lisp programming language the process of reorganizing common behavior from nonabstract classes into abstract classes using inheritance to abstract over subclasses as seen in the objectoriented c and java programming languages rationale computing mostly operates independently of the concrete world the hardware implements a model of computation that is interchangeable with others the software is structured in architectures to enable humans to create the enormous systems by concentrating on a few issues at a time these architectures are made of specific choices of abstractions greenspuns tenth rule is an aphorism on how such an architecture is both inevitable and complex a central form of abstraction in computing is language abstraction new artificial languages are developed to express specific aspects of a system modeling languages help in planning computer languages can be processed with a computer an example of this abstraction process is the generational development of programming languages from the machine language to the assembly language and the highlevel language each stage can be used as a stepping stone for the next stage the language abstraction continues for example in scripting languages and domainspecific programming languages within a programming language some features let the programmer create new abstractions these include subroutines modules polymorphism and software components some other abstractions such as software design patterns and architectural styles remain invisible to a translator and operate only in the design of a system some abstractions try to limit the range of concepts a programmer needs to be aware of by completely hiding the abstractions that they in turn are built on the software engineer and writer joel spolsky has criticised these efforts by claiming that all abstractions are leaky that they can never completely hide the details below however this does not negate the usefulness of abstraction some abstractions are designed to interoperate with other abstractions for example a programming language may contain a foreign function interface for making calls to the lowerlevel language in simple terms abstraction is removing irrelevant data so a program is easier to understand language features programming languages programming language different programming languages provide different types of abstraction depending on the intended applications for the language for example in objectoriented programming languages such as c object pascal or java the concept of abstraction has itself become a declarative statement using the keywords virtual in c or abstract in java after such a declaration it is the responsibility of the programmer to implement a class to instantiate the object of the declaration functional programming languages commonly exhibit abstractions related to functions such as lambda abstractions making a term into a function of some variable and higherorder functions parameters are functions modern members of the lisp programming language family such as clojure scheme and common lisp support macro systems to allow syntactic abstraction other programming languages such as scala also have macros or very similar metaprogramming features for example haskell has template haskell and ocaml has metaocaml these can allow a programmer to eliminate boilerplate code abstract away tedious function call sequences implement new control flow structures and implement domain specific languages dsls which allow domainspecific concepts to be expressed in concise and elegant ways all of these when used correctly improve both the programmers efficiency and the clarity of the code by making the intended purpose more explicit a consequence of syntactic abstraction is also that any lisp dialect and in fact almost any programming language can in principle be implemented in any modern lisp with significantly reduced but still nontrivial in some cases effort when compared to more traditional programming languages such as python c or java specification methods formal specification analysts have developed various methods to formally specify software systems some known methods include abstractmodel based method vdm z algebraic techniques larch clear obj act one casl processbased techniques lotos sdl estelle tracebased techniques special tam knowledgebased techniques refine gist specification languages specification language specification languages generally rely on abstractions of one kind or another since specifications are typically defined earlier in a project and at a more abstract level than an eventual implementation the uml specification language for example allows the definition of abstract classes which in a waterfall project remain abstract during the architecture and specification phase of the project control abstraction control flow programming languages offer control abstraction as one of the main purposes of their use computer machines understand operations at the very low level such as moving some bits from one location of the memory to another location and producing the sum of two sequences of bits programming languages allow this to be done in the higher level for example consider this statement written in a pascallike fashion a 1 2 5 to a human this seems a fairly simple and obvious calculation one plus two is three times five is fifteen however the lowlevel steps necessary to carry out this evaluation and return the value 15 and then assign that value to the variable a are actually quite subtle and complex the values need to be converted to binary representation often a much more complicated task than one would think and the calculations decomposed by the compiler or interpreter into assembly instructions again which are much less intuitive to the programmer operations such as shifting a binary register left or adding the binary complement of the contents of one register to another are simply not how humans think about the abstract arithmetical operations of addition or multiplication finally assigning the resulting value of 15 to the variable labeled a so that a can be used later involves additional behindthescenes steps of looking up a variables label and the resultant location in physical or virtual memory storing the binary representation of 15 to that memory location etc without control abstraction a programmer would need to specify all the registerbinarylevel steps each time they simply wanted to add or multiply a couple of numbers and assign the result to a variable such duplication of effort has two serious negative consequences it forces the programmer to constantly repeat fairly common tasks every time a similar operation is needed it forces the programmer to program for the particular hardware and instruction set structured programming structured programming structured programming involves the splitting of complex program tasks into smaller pieces with clear flowcontrol and interfaces between components with reduction of the complexity potential for sideeffects in a simple program this may aim to ensure that loops have single or obvious exit points and where possible to have single exit points from functions and procedures in a larger system it may involve breaking down complex tasks into many different modules consider a system which handles payroll on ships and at shore offices the uppermost level may feature a menu of typical enduser operations within that could be standalone executables or libraries for tasks such as signing on and off employees or printing checks within each of those standalone components there could be many different source files each containing the program code to handle a part of the problem with only selected interfaces available to other parts of the program a sign on program could have source files for each data entry screen and the database interface which may itself be a standalone third party library or a statically linked set of library routines either the database or the payroll application also has to initiate the process of exchanging data with between ship and shore and that data transfer task will often contain many other components these layers produce the effect of isolating the implementation details of one component and its assorted internal methods from the others objectoriented programming embraces and extends this concept data abstraction abstract data type data abstraction enforces a clear separation between the abstract properties of a data type and the concrete details of its implementation the abstract properties are those that are visible to client code that makes use of the data typethe interface to the data typewhile the concrete implementation is kept entirely private and indeed can change for example to incorporate efficiency improvements over time the idea is that such changes are not supposed to have any impact on client code since they involve no difference in the abstract behaviour for example one could define an abstract data type called lookup table which uniquely associates keys with values and in which values may be retrieved by specifying their corresponding keys such a lookup table may be implemented in various ways as a hash table a binary search tree or even a simple linear list of keyvalue pairs as far as client code is concerned the abstract properties of the type are the same in each case of course this all relies on getting the details of the interface right in the first place since any changes there can have major impacts on client code as one way to look at this the interface forms a contract on agreed behaviour between the data type and client code anything not spelled out in the contract is subject to change without notice abstraction in object oriented programming object computer science in objectoriented programming theory abstraction involves the facility to define objects that represent abstract actors that can perform work report on and change their state and communicate with other objects in the system the term encapsulation refers to the hiding of state details but extending the concept of data type from earlier programming languages to associate behavior most strongly with the data and standardizing the way that different data types interact is the beginning of abstraction when abstraction proceeds into the operations defined enabling objects of different types to be substituted it is called polymorphism when it proceeds in the opposite direction inside the types or classes structuring them to simplify a complex set of relationships it is called delegation or inheritance various objectoriented programming languages offer similar facilities for abstraction all to support a general strategy of polymorphism in objectoriented programming which includes the substitution of one type for another in the same or similar role although not as generally supported a configuration or image or package may predetermine a great many of these bindings at compiletime linktime or loadtime this would leave only a minimum of such bindings to change at runtime common lisp object system or self for example feature less of a classinstance distinction and more use of delegation for polymorphism individual objects and functions are abstracted more flexibly to better fit with a shared functional heritage from lisp c exemplifies another extreme it relies heavily on templates and overloading and other static bindings at compiletime which in turn has certain flexibility problems although these examples offer alternate strategies for achieving the same abstraction they do not fundamentally alter the need to support abstract nouns in code all programming relies on an ability to abstract verbs as functions nouns as data structures and either as processes consider for example a sample java fragment to represent some common farm animals to a level of abstraction suitable to model simple aspects of their hunger and feeding it defines an animal class to represent both the state of the animal and its functions public class animal extends livingthing private location loc private double energyreserves public boolean ishungry return energyreserves 25 public void eatfood food consume food energyreserves foodgetcalories public void movetolocation location move to new location thisloc location with the above definition one could create objects of type animal and call their methods like this thepig new animal thecow new animal if thepigishungry thepigeattablescraps if thecowishungry thecoweatgrass thecowmovetothebarn in the above example the class animal is an abstraction used in place of an actual animal livingthing is a further abstraction in this case a generalisation of animal if one requires a more differentiated hierarchy of animals to differentiate say those who provide milk from those who provide nothing except meat at the end of their lives that is an intermediary level of abstraction probably dairyanimal cows goats who would eat foods suitable to giving good milk and meatanimal pigs steers who would eat foods to give the best meatquality such an abstraction could remove the need for the application coder to specify the type of food so she could concentrate instead on the feeding schedule the two classes could be related using inheritance or stand alone and the programmer could define varying degrees of polymorphism between the two types these facilities tend to vary drastically between languages but in general each can achieve anything that is possible with any of the others a great many operation overloads data type by data type can have the same effect at compiletime as any degree of inheritance or other means to achieve polymorphism the class notation is simply a coders convenience objectoriented design objectoriented design decisions regarding what to abstract and what to keep under the control of the coder become the major concern of objectoriented design and domain analysisactually determining the relevant relationships in the real world is the concern of objectoriented analysis or legacy analysis in general to determine appropriate abstraction one must make many small decisions about scope domain analysis determine what other systems one must cooperate with legacy analysis then perform a detailed objectoriented analysis which is expressed within project time and budget constraints as an objectoriented design in our simple example the domain is the barnyard the live pigs and cows and their eating habits are the legacy constraints the detailed analysis is that coders must have the flexibility to feed the animals what is available and thus there is no reason to code the type of food into the class itself and the design is a single simple animal class of which pigs and cows are instances with the same functions a decision to differentiate dairyanimal would change the detailed analysis but the domain and legacy analysis would be unchangedthus it is entirely under the control of the programmer and we refer to abstraction in objectoriented programming as distinct from abstraction in domain or legacy analysis considerations when discussing formal semantics of programming languages formal methods or abstract interpretation abstraction refers to the act of considering a less detailed but safe definition of the observed program behaviors for instance one may observe only the final result of program executions instead of considering all the intermediate steps of executions abstraction is defined to a concrete more precise model of execution abstraction may be exact or faithful with respect to a property if one can answer a question about the property equally well on the concrete or abstract model for instance if we wish to know what the result of the evaluation of a mathematical expression involving only integers is worth modulo n we need only perform all operations modulo n a familiar form of this abstraction is casting out nines abstractions however though not necessarily exact should be sound that is it should be possible to get sound answers from themeven though the abstraction may simply yield a result of undecidability for instance we may abstract the students in a class by their minimal and maximal ages if one asks whether a certain person belongs to that class one may simply compare that persons age with the minimal and maximal ages if his age lies outside the range one may safely answer that the person does not belong to the class if it does not one may only answer i dont know the level of abstraction included in a programming language can influence its overall usability the cognitive dimensions framework includes the concept of abstraction gradient in a formalism this framework allows the designer of a programming language to study the tradeoffs between abstraction and other characteristics of the design and how changes in abstraction influence the language usability abstractions can prove useful when dealing with computer programs because nontrivial properties of computer programs are essentially undecidable see rices theorem as a consequence automatic methods for deriving information on the behavior of computer programs either have to drop termination on some occasions they may fail crash or never yield out a result soundness they may provide false information or precision they may answer i dont know to some questions abstraction is the core concept of abstract interpretation model checking generally takes place on abstract versions of the studied systems levels of abstraction abstraction layer computer science commonly presents levels or less commonly layers of abstraction wherein each level represents a different model of the same information and processes but with varying amounts of detail each level uses a system of expression involving a unique set of objects and compositions that apply only to a particular domain each relatively abstract higher level builds on a relatively concrete lower level which tends to provide an increasingly granular representation for example gates build on electronic circuits binary on gates machine language on binary programming language on machine language applications and operating systems on programming languages each level is embodied but not determined by the level beneath it making it a language of description that is somewhat selfcontained database systems database management system since many users of database systems lack indepth familiarity with computer datastructures database developers often hide complexity through the following levels data abstraction levels of a database system physical level the lowest level of abstraction describes how a system actually stores data the physical level describes complex lowlevel data structures in detail logical level the next higher level of abstraction describes what data the database stores and what relationships exist among those data the logical level thus describes an entire database in terms of a small number of relatively simple structures although implementation of the simple structures at the logical level may involve complex physical level structures the user of the logical level does not need to be aware of this complexity this is referred to as physical data independence database administrators who must decide what information to keep in a database use the logical level of abstraction view level the highest level of abstraction describes only part of the entire database even though the logical level uses simpler structures complexity remains because of the variety of information stored in a large database many users of a database system do not need all this information instead they need to access only a part of the database the view level of abstraction exists to simplify their interaction with the system the system may provide many views for the same database layered architecture abstraction layer the ability to provide a design of different levels of abstraction can simplify the design considerably enable different role players to effectively work at various levels of abstraction support the portability of software artifacts modelbased ideally systems design and business process design can both use this some design processes specifically generate designs that contain various levels of abstraction layered architecture partitions the concerns of the application into stacked groups layers it is a technique used in designing computer software hardware and communications in which system or network components are isolated in layers so that changes can be made in one layer without affecting the others abstraction principle computer programming abstraction inversion for an antipattern of one danger in abstraction abstract data type for an abstract description of a set of data algorithm for an abstract description of a computational procedure bracket abstraction for making a term into a function of a variable data modeling for structuring data independent of the processes that use it encapsulation for abstractions that hide implementation details greenspuns tenth rule for an aphorism about an the optimum point in the space of abstractions higherorder function for abstraction where functions produce or consume other functions lambda abstraction for making a term into a function of some variable list of abstractions computer science refinement for the opposite of abstraction in computing this article is based on material taken from the free online dictionary of computing prior to 1 november 2008 and incorporated under the relicensing terms of the gfdl version 13 or later mwparseroutput refbeginfontsize90marginbottom05emmwparseroutput refbeginhangingindentsulliststyletypenonemarginleft0mwparseroutput refbeginhangingindentsullimwparseroutput refbeginhangingindentsdlddmarginleft0paddingleft32emtextindent32emliststylenonemwparseroutput refbegin100fontsize100 harold abelson gerald jay sussman julie sussman 25 july 1996 structure and interpretation of computer programs 2 ed mit press isbn9780262011532 archived from the original on 26 february 2009 retrieved 22 june 2012 spolsky joel 11 november 2002 the law of leaky abstractions joel on software abstractioninformation hiding cs211 course cornell university eric s roberts 1997 programming abstractions in c a second course in computer science palermo jeffrey 29 july 2008 the onion architecture jeffrey palermo simarch example of layered architecture for distributed simulation systems 