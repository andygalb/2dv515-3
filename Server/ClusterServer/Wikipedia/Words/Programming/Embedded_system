embedded system an embedded system on a plugin card with processor memory power supply and external interfaces an embedded system is a programmed controlling and operating system with a dedicated function within a larger mechanical or electrical system often with realtime computing constraints examples of properties of typical embedded computers when compared with generalpurpose counterparts are low power consumption small size rugged operating ranges and low perunit cost this comes at the price of limited processing resources which make them significantly more difficult to program and to interact with however by building intelligence mechanisms on top of the hardware taking advantage of possible existing sensors and the existence of a network of embedded units one can both optimally manage available resources at the unit and network levels as well as provide augmented functions well beyond those available modern embedded systems are often based on microcontrollers ie cpus with integrated memory or peripheral interfaces but ordinary microprocessors using external chips for memory and peripheral interface circuits are also common especially in more complex systems in either case the processors used may be types ranging from general purpose to those specialized in certain class of computations or even custom designed for the application at hand a common standard class of dedicated processors is the digital signal processor dsp since the embedded system is dedicated to specific tasks design engineers can optimize it to reduce the size and cost of the product and increase the reliability and performance some embedded systems are massproduced benefiting from economies of scale embedded systems range from portable devices such as digital watches and mp3 players to large stationary installations like traffic lights factory controllers and largely complex systems like hybrid vehicles mri and avionics complexity varies from low with a single microcontroller chip to very high with multiple units peripherals and networks mounted inside a large chassis or enclosure history one of the very first recognizably modern embedded systems was the apollo guidance computer developed ca 1965 by charles stark draper at the mit instrumentation laboratory at the projects inception the apollo guidance computer was considered the riskiest item in the apollo project as it employed the then newly developed monolithic integrated circuits to reduce the size and weight an early massproduced embedded system was the autonetics d17 guidance computer for the minuteman missile released in 1961 when the minuteman ii went into production in 1966 the d17 was replaced with a new computer that was the first highvolume use of integrated circuits since these early applications in the 1960s embedded systems have come down in price and there has been a dramatic rise in processing power and functionality an early microprocessor for example the intel 4004 released in 1971 was designed for calculators and other small systems but still required external memory and support chips in 1978 national engineering manufacturers association released a standard for programmable microcontrollers including almost any computerbased controllers such as single board computers numerical and eventbased controllers as the cost of microprocessors and microcontrollers fell it became feasible to replace expensive knobbased analog components such as potentiometers and variable capacitors with updown buttons or knobs read out by a microprocessor even in consumer products by the early 1980s memory input and output system components had been integrated into the same chip as the processor forming a microcontroller microcontrollers find applications where a generalpurpose computer would be too costly a comparatively lowcost microcontroller may be programmed to fulfill the same role as a large number of separate components although in this context an embedded system is usually more complex than a traditional solution most of the complexity is contained within the microcontroller itself very few additional components may be needed and most of the design effort is in the software software prototype and test can be quicker compared with the design and construction of a new circuit not using an embedded processor applications embedded computer subassembly for accupoll electronic voting machine embedded systems are commonly found in consumer cooking industrial automotive medical commercial and military applications telecommunications systems employ numerous embedded systems from telephone switches for the network to cell phones at the end user computer networking uses dedicated routers and network bridges to route data consumer electronics include mp3 players mobile phones video game consoles digital cameras gps receivers and printers household appliances such as microwave ovens washing machines and dishwashers include embedded systems to provide flexibility efficiency and features advanced hvac systems use networked thermostats to more accurately and efficiently control temperature that can change by time of day and season home automation uses wired and wirelessnetworking that can be used to control lights climate security audiovisual surveillance etc all of which use embedded devices for sensing and controlling transportation systems from flight to automobiles increasingly use embedded systems new airplanes contain advanced avionics such as inertial guidance systems and gps receivers that also have considerable safety requirements various electric motors brushless dc motors induction motors and dc motors use electricelectronic motor controllers automobiles electric vehicles and hybrid vehicles increasingly use embedded systems to maximize efficiency and reduce pollution other automotive safety systems include antilock braking system abs electronic stability control escesp traction control tcs and automatic fourwheel drive medical equipment uses embedded systems for vital signs monitoring electronic stethoscopes for amplifying sounds and various medical imaging pet spect ct and mri for noninvasive internal inspections embedded systems within medical equipment are often powered by industrial computers embedded systems are used in transportation fire safety safety and security medical applications and life critical systems as these systems can be isolated from hacking and thus be more reliable unless connected to wired or wireless networks via onchip 3g cellular or other methods for iot monitoring and control purposes for fire safety the systems can be designed to have greater ability to handle higher temperatures and continue to operate in dealing with security the embedded systems can be selfsufficient and be able to deal with cut electrical and communication systems a new class of miniature wireless devices called motes are networked wireless sensors wireless sensor networking wsn makes use of miniaturization made possible by advanced ic design to couple full wireless subsystems to sophisticated sensors enabling people and companies to measure a myriad of things in the physical world and act on this information through it monitoring and control systems these motes are completely selfcontained and will typically run off a battery source for years before the batteries need to be changed or charges embedded wifi modules provide a simple means of wirelessly enabling any device that communicates via a serial port characteristics embedded systems are designed to do some specific task rather than be a generalpurpose computer for multiple tasks some also have realtime performance constraints that must be met for reasons such as safety and usability others may have low or no performance requirements allowing the system hardware to be simplified to reduce costs embedded systems are not always standalone devices many embedded systems consist of small parts within a larger device that serves a more general purpose for example the gibson robot guitar features an embedded system for tuning the strings but the overall purpose of the robot guitar is of course to play music similarly an embedded system in an automobile provides a specific function as a subsystem of the car itself econ systems esom270 esom300 computer on modules the program instructions written for embedded systems are referred to as firmware and are stored in readonly memory or flash memory chips they run with limited computer hardware resources little memory small or nonexistent keyboard or screen user interface embedded system text user interface using microvga embedded systems range from no user interface at all in systems dedicated only to one task to complex graphical user interfaces that resemble modern computer desktop operating systems simple embedded devices use buttons leds graphic or character lcds hd44780 lcd for example with a simple menu system more sophisticated devices that use a graphical screen with touch sensing or screenedge buttons provide flexibility while minimizing space used the meaning of the buttons can change with the screen and selection involves the natural behavior of pointing at what is desired handheld systems often have a screen with a joystick button for a pointing device some systems provide user interface remotely with the help of a serial eg rs232 usb ic etc or network eg ethernet connection this approach gives several advantages extends the capabilities of embedded system avoids the cost of a display simplifies bsp and allows one to build a rich user interface on the pc a good example of this is the combination of an embedded web server running on an embedded device such as an ip camera or a network router the user interface is displayed in a web browser on a pc connected to the device therefore needing no software to be installed processors in embedded systems embedded processors can be broken into two broad categories ordinary microprocessors p use separate integrated circuits for memory and peripherals microcontrollers c have onchip peripherals thus reducing power consumption size and cost in contrast to the personal computer market many different basic cpu architectures are used since software is customdeveloped for an application and is not a commodity product installed by the end user both von neumann as well as various degrees of harvard architectures are used risc as well as nonrisc processors are found word lengths vary from 4bit to 64bits and beyond although the most typical remain 816bit most architectures come in a large number of different variants and shapes many of which are also manufactured by several different companies numerous microcontrollers have been developed for embedded systems use generalpurpose microprocessors are also used in embedded systems but generally require more support circuitry than microcontrollers readymade computer boards pc104 and pc104 are examples of standards for readymade computer boards intended for small lowvolume embedded and ruggedized systems mostly x86based these are often physically small compared to a standard pc although still quite large compared to most simple 816bit embedded systems they often use dos linux netbsd or an embedded realtime operating system such as microcosii qnx or vxworks sometimes these boards use nonx86 processors in certain applications where small size or power efficiency are not primary concerns the components used may be compatible with those used in general purpose x86 personal computers boards such as the via epia range help to bridge the gap by being pccompatible but highly integrated physically smaller or have other attributes making them attractive to embedded engineers the advantage of this approach is that lowcost commodity components may be used along with the same software development tools used for general software development systems built in this way are still regarded as embedded since they are integrated into larger devices and fulfill a single role examples of devices that may adopt this approach are atms and arcade machines which contain code specific to the application however most readymade embedded systems boards are not pccentered and do not use the isa or pci buses when a systemonachip processor is involved there may be little benefit to having a standardized bus connecting discrete components and the environment for both hardware and software tools may be very different one common design style uses a small system module perhaps the size of a business card holding high density bga chips such as an armbased systemonachip processor and peripherals external flash memory for storage and dram for runtime memory the module vendor will usually provide boot software and make sure there is a selection of operating systems usually including linux and some real time choices these modules can be manufactured in high volume by organizations familiar with their specialized testing issues and combined with much lower volume custom mainboards with applicationspecific external peripherals implementation of embedded systems has advanced so that they can easily be implemented with alreadymade boards that are based on worldwide accepted platforms these platforms include but are not limited to arduino and raspberry pi asic and fpga solutions a common array for veryhighvolume embedded systems is the system on a chip soc that contains a complete system consisting of multiple processors multipliers caches and interfaces on a single chip socs can be implemented as an applicationspecific integrated circuit asic or using a fieldprogrammable gate array fpga peripherals a closeup of the smsc lan91c110 smsc 91x chip an embedded ethernet chip embedded systems talk with the outside world via peripherals such as serial communication interfaces sci rs232 rs422 rs485 etc synchronous serial communication interface i2c spi ssc and essi enhanced synchronous serial interface universal serial bus usb multi media cards sd cards compact flash etc networks ethernet lonworks etc fieldbuses canbus linbus profibus etc timers plls capturecompare and time processing units discrete io aka general purpose inputoutput gpio analog to digitaldigital to analog adcdac debugging jtag isp icsp bdm port bitp and db9 ports tools as with other software embedded system designers use compilers assemblers and debuggers to develop embedded system software however they may also use some more specific tools in circuit debuggers or emulators see next section utilities to add a checksum or crc to a program so the embedded system can check if the program is valid for systems using digital signal processing developers may use a math workbench to simulate the mathematics system level modeling and simulation tools help designers to construct simulation models of a system with hardware components such as processors memories dma interfaces buses and software behavior flow as a state diagram or flow diagram using configurable library blocks simulation is conducted to select right components by performing power vs performance tradeoff reliability analysis and bottleneck analysis typical reports that helps designer to make architecture decisions includes application latency device throughput device utilization power consumption of the full system as well as devicelevel power consumption a modelbased development tool creates and simulate graphical data flow and uml state chart diagrams of components like digital filters motor controllers communication protocol decoding and multirate tasks custom compilers and linkers may be used to optimize specialized hardware an embedded system may have its own special language or design tool or add enhancements to an existing language such as forth or basic another alternative is to add a realtime operating system or embedded operating system modeling and code generating tools often based on state machines software tools can come from several sources software companies that specialize in the embedded market ported from the gnu software development tools sometimes development tools for a personal computer can be used if the embedded processor is a close relative to a common pc processor as the complexity of embedded systems grows higher level tools and operating systems are migrating into machinery where it makes sense for example cellphones personal digital assistants and other consumer computers often need significant software that is purchased or provided by a person other than the manufacturer of the electronics in these systems an open programming environment such as linux netbsd osgi or embedded java is required so that the thirdparty software provider can sell to a large market embedded systems are commonly found in consumer cooking industrial automotive medical applications some examples of embedded systems are mp3 players mobile phones video game consoles digital cameras dvd players and gps household appliances such as microwave ovens washing machines and dishwashers include embedded systems to provide flexibility and efficiency debugging embedded debugging may be performed at different levels depending on the facilities available the different metrics that characterize the different forms of embedded debugging are does it slow down the main application how close is the debugged system or application to the actual system or application how expressive are the triggers that can be set for debugging eg inspecting the memory when a particular program counter value is reached and what can be inspected in the debugging process such as only memory or memory and registers etc from simplest to most sophisticated they can be roughly grouped into the following areas interactive resident debugging using the simple shell provided by the embedded operating system eg forth and basic external debugging using logging or serial port output to trace operation using either a monitor in flash or using a debug server like the remedy debugger that even works for heterogeneous multicore systems an incircuit debugger icd a hardware device that connects to the microprocessor via a jtag or nexus interface this allows the operation of the microprocessor to be controlled externally but is typically restricted to specific debugging capabilities in the processor an incircuit emulator ice replaces the microprocessor with a simulated equivalent providing full control over all aspects of the microprocessor a complete emulator provides a simulation of all aspects of the hardware allowing all of it to be controlled and modified and allowing debugging on a normal pc the downsides are expense and slow operation in some cases up to 100 times slower than the final system for soc designs the typical approach is to verify and debug the design on an fpga prototype board tools such as certus are used to insert probes in the fpga rtl that make signals available for observation this is used to debug hardware firmware and software interactions across multiple fpga with capabilities similar to a logic analyzer softwareonly debuggers have the benefit that they do not need any hardware modification but have to carefully control what they record in order to conserve time and storage space unless restricted to external debugging the programmer can typically load and run software through the tools view the code running in the processor and start or stop its operation the view of the code may be as hll sourcecode assembly code or mixture of both because an embedded system is often composed of a wide variety of elements the debugging strategy may vary for instance debugging a software and microprocessor centric embedded system is different from debugging an embedded system where most of the processing is performed by peripherals dsp fpga and coprocessor an increasing number of embedded systems today use more than one single processor core a common problem with multicore development is the proper synchronization of software execution in this case the embedded system design may wish to check the data traffic on the busses between the processor cores which requires very lowlevel debugging at signalbus level with a logic analyzer for instance tracing realtime operating systems rtos often supports tracing of operating system events a graphical view is presented by a host pc tool based on a recording of the system behavior the trace recording can be performed in software by the rtos or by special tracing hardware rtos tracing allows developers to understand timing and performance issues of the software system and gives a good understanding of the highlevel system behaviors commercial tools like rtxc quadros or iar systems exists reliability embedded systems often reside in machines that are expected to run continuously for years without errors and in some cases recover by themselves if an error occurs therefore the software is usually developed and tested more carefully than that for personal computers and unreliable mechanical moving parts such as disk drives switches or buttons are avoided specific reliability issues may include the system cannot safely be shut down for repair or it is too inaccessible to repair examples include space systems undersea cables navigational beacons borehole systems and automobiles the system must be kept running for safety reasons limp modes are less tolerable often backups are selected by an operator examples include aircraft navigation reactor control systems safetycritical chemical factory controls train signals the system will lose large amounts of money when shut down telephone switches factory controls bridge and elevator controls funds transfer and market making automated sales and service a variety of techniques are used sometimes in combination to recover from errorsboth software bugs such as memory leaks and also soft errors in the hardware watchdog timer that resets the computer unless the software periodically notifies the watchdog subsystems with redundant spares that can be switched over to software limp modes that provide partial function designing with a trusted computing base tcb architecture ensures a highly secure reliable system environment a hypervisor designed for embedded systems is able to provide secure encapsulation for any subsystem component so that a compromised software component cannot interfere with other subsystems or privilegedlevel system software this encapsulation keeps faults from propagating from one subsystem to another improving reliability this may also allow a subsystem to be automatically shut down and restarted on fault detection immunity aware programming high vs low volume for high volume systems such as portable music players or mobile phones minimizing cost is usually the primary design consideration engineers typically select hardware that is just good enough to implement the necessary functions for lowvolume or prototype embedded systems general purpose computers may be adapted by limiting the programs or by replacing the operating system with a realtime operating system embedded software architectures embedded software there are several different types of software architecture in common use simple control loop in this design the software simply has a loop the loop calls subroutines each of which manages a part of the hardware or software hence it is called a simple control loop or control loop interruptcontrolled system some embedded systems are predominantly controlled by interrupts this means that tasks performed by the system are triggered by different kinds of events an interrupt could be generated for example by a timer in a predefined frequency or by a serial port controller receiving a byte these kinds of systems are used if event handlers need low latency and the event handlers are short and simple usually these kinds of systems run a simple task in a main loop also but this task is not very sensitive to unexpected delays sometimes the interrupt handler will add longer tasks to a queue structure later after the interrupt handler has finished these tasks are executed by the main loop this method brings the system close to a multitasking kernel with discrete processes cooperative multitasking a nonpreemptive multitasking system is very similar to the simple control loop scheme except that the loop is hidden in an api the programmer defines a series of tasks and each task gets its own environment to run in when a task is idle it calls an idle routine usually called pause wait yield nop stands for no operation etc the advantages and disadvantages are similar to that of the control loop except that adding new software is easier by simply writing a new task or adding to the queue preemptive multitasking or multithreading in this type of system a lowlevel piece of code switches between tasks or threads based on a timer connected to an interrupt this is the level at which the system is generally considered to have an operating system kernel depending on how much functionality is required it introduces more or less of the complexities of managing multiple tasks running conceptually in parallel as any code can potentially damage the data of another task except in larger systems using an mmu programs must be carefully designed and tested and access to shared data must be controlled by some synchronization strategy such as message queues semaphores or a nonblocking synchronization scheme because of these complexities it is common for organizations to use a realtime operating system rtos allowing the application programmers to concentrate on device functionality rather than operating system services at least for large systems smaller systems often cannot afford the overhead associated with a generic realtime system due to limitations regarding memory size performance or battery life the choice that an rtos is required brings in its own issues however as the selection must be done prior to starting to the application development process this timing forces developers to choose the embedded operating system for their device based upon current requirements and so restricts future options to a large extent the restriction of future options becomes more of an issue as product life decreases additionally the level of complexity is continuously growing as devices are required to manage variables such as serial usb tcpip bluetooth wireless lan trunk radio multiple channels data and voice enhanced graphics multiple states multiple threads numerous wait states and so on these trends are leading to the uptake of embedded middleware in addition to a realtime operating system microkernels and exokernels a microkernel is a logical step up from a realtime os the usual arrangement is that the operating system kernel allocates memory and switches the cpu to different threads of execution user mode processes implement major functions such as file systems network interfaces etc in general microkernels succeed when the task switching and intertask communication is fast and fail when they are slow exokernels communicate efficiently by normal subroutine calls the hardware and all the software in the system are available to and extensible by application programmers monolithic kernels in this case a relatively large kernel with sophisticated capabilities is adapted to suit an embedded environment this gives programmers an environment similar to a desktop operating system like linux or microsoft windows and is therefore very productive for development on the downside it requires considerably more hardware resources is often more expensive and because of the complexity of these kernels can be less predictable and reliable common examples of embedded monolithic kernels are embedded linux and windows ce despite the increased cost in hardware this type of embedded system is increasing in popularity especially on the more powerful embedded devices such as wireless routers and gps navigation systems here are some of the reasons ports to common embedded chip sets are available they permit reuse of publicly available code for device drivers web servers firewalls and other code development systems can start out with broad featuresets and then the distribution can be configured to exclude unneeded functionality and save the expense of the memory that it would consume many engineers believe that running application code in user mode is more reliable and easier to debug thus making the development process easier and the code more portable features requiring faster response than can be guaranteed can often be placed in hardware additional software components in addition to the core operating system many embedded systems have additional upperlayer software components these components consist of networking protocol stacks like can tcpip ftp http and https and also included storage capabilities like fat and flash memory management systems if the embedded device has audio and video capabilities then the appropriate drivers and codecs will be present in the system in the case of the monolithic kernels many of these software layers are included in the rtos category the availability of the additional software components depends upon the commercial offering electronics portal communications server cyberphysical system dsp electronic control unit hypervisor embedded operating systems embedded software firmware fpga information appliance microprocessor microcontroller silicon compiler realtime operating system software engineering system on a chip system on module ubiquitous computing photonically optimized embedded microprocessors notes john catsoulis may 2005 designing embedded hardware 2nd edition oreilly isbn0596007558 james m conrad alexander g dean september 2011 embedded systems an introduction using the renesas rx62n microcontroller micrium isbn9781935772996 klaus elk august 2016 embedded software development for the internet of things the basics the technologies and best practices isbn9781534602533 wikimedia commons has media related to embedded systems wikibooks has a book on the topic of embedded systems wikiversity has learning resources about embedded system engineering embedded systems course with mbed youtube ongoing from 2015 trends in cyber security and embedded systems dan geer november 2013 modern embedded systems programming video course youtube ongoing from 2013 embedded systems week esweek yearly event with conferences workshops and tutorials covering all aspects of embedded systems and software workshop on embedded and cyberphysical systems education workshop covering educational aspects of embedded systems vtecomputer sizesclasses of computersmicrocomputerpersonalcomputerstationary workstation desktop home personal supercomputer portable tabletop smart tv interactive kiosk game arcade cabinet system board home console microconsole sff nettop plug smart speaker mobilelaptop desktop replacement 2in1 subnotebook netbook smartbook ultrabook ultramobile pc tablet ultramobile pc 2in1 phablet tabletop handheld handheld pc palmtop pc pocket computer pda electronic organizer mobile phone feature phone smartphone phablet pmp ereader handheld game console portablemobile data terminal calculator scientific programmable graphing wearable digital wristwatch calculator watch smartwatch smartglasses smart ring midrange server minicomputer supermini large super mainframe minisuper others microcontroller nanocomputer singleboard computer smartdust wireless sensor network vtemajor fields of computer sciencenote this template roughly follows the 2012 acm computing classification systemhardware printed circuit board peripheral integrated circuit very large scale integration systems on chip socs energy consumption green computing electronic design automation hardware acceleration computer systemsorganization computer architecture embedded system realtime computing dependability networks network architecture network protocol network components network scheduler network performance evaluation network service software organization interpreter middleware virtual machine operating system software quality software notationsand tools programming paradigm programming language compiler domainspecific language modeling language software framework integrated development environment software configuration management software library software repository software development software development process requirements analysis software design software construction software deployment software maintenance programming team opensource model theory of computation model of computation formal language automata theory computational complexity theory logic semantics algorithms algorithm design analysis of algorithms algorithmic efficiency randomized algorithm computational geometry mathematicsof computing discrete mathematics probability statistics mathematical software information theory mathematical analysis numerical analysis informationsystems database management system information storage systems enterprise information system social information systems geographic information system decision support system process control system multimedia information system data mining digital library computing platform digital marketing world wide web information retrieval security cryptography formal methods security services intrusion detection system hardware security network security information security application security humancomputerinteraction interaction design social computing ubiquitous computing visualization accessibility concurrency concurrent computing parallel computing distributed computing multithreading multiprocessing artificialintelligence natural language processing knowledge representation and reasoning computer vision automated planning and scheduling search methodology control method philosophy of artificial intelligence distributed artificial intelligence machine learning supervised learning unsupervised learning reinforcement learning multitask learning crossvalidation graphics animation rendering image manipulation graphics processing unit mixed reality virtual reality image compression solid modeling appliedcomputing ecommerce enterprise software computational mathematics computational physics computational chemistry computational biology computational social science computational engineering computational healthcare digital art electronic publishing cyberwarfare electronic voting video games word processing operations research educational technology document management book category portal wikiproject commons vteembedded systemsgeneral terms embedded software original equipment manufacturer oem embedded database embedded hypervisor consumer electronics microcontroller asic fpga soc memory footprint singleboard computer raspberry pi iot board support package cross compiler embedded os bootloader firmware and controls custom firmware rooting android ios jailbreaking playstation 3 jailbreak closed platform vendor lockin defective by design hacking of consumer electronics homebrew video games crippleware software libraries uclibc dietlibc embedded glibc musl development tools bitbake buildroot busybox yocto project almquist shell standalone shell openembedded operating systems linux on embedded systems linux for mobile devices lightweight linux distribution windows iot win ce realtime operating system programming languages ada assembly language capl embedded c misra c nesc embedded c embedded java lightweight browsers opensource computing hardware opensource robotics authority control bnf cb12410613b data gnd 43969781 lccn sh87006632 ndl 01064710 