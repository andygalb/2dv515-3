continuous integration software development core activities processes requirements design engineering construction testing debugging deployment maintenance paradigms and models agile cleanroom incremental prototyping spiral v model waterfall methodologies and frameworks asd devops dad dsdm fdd iid kanban lean sd less mdd msf psp rad rup safe scrum semat tsp up xp supporting disciplines configuration management documentation software quality assurance sqa project management user experience practices atdd bdd cco ci cd ddd pp standup tdd tools compiler debugger profiler gui designer modeling ide build automation release automation infrastructure as code testing standards and bodies of knowledge babok cmmi ieee standards iso 9001 isoiec standards pmbok swebok itil glossaries artificial intelligence computer science electrical and electronics engineering vte in software engineering continuous integration ci is the practice of merging all developer working copies to a shared mainline several times a day rationale the main aim of ci is to prevent integration problems referred to as integration hell in early descriptions of xp ci is not universally accepted as an improvement over frequent integration so it is important to distinguish between the two as there is disagreement about the virtues of each in xp ci was intended to be used in combination with automated unit tests written through the practices of testdriven development initially this was conceived of as running and passing all unit tests in the developers local environment before committing to the mainline this helps avoid one developers workinprogress breaking another developers copy where necessary partially complete features can be disabled before committing using feature toggles for instance later elaborations of the concept introduced build servers which automatically ran the unit tests periodically or even after every commit and reported the results to the developers the use of build servers not necessarily running unit tests had already been practised by some teams outside the xp community nowadays many organisations have adopted ci without adopting all of xp in addition to automated unit tests organisations using ci typically use a build server to implement continuous processes of applying quality control in general small pieces of effort applied frequently in addition to running the unit and integration tests such processes run additional static and dynamic tests measure and profile performance extract and format documentation from the source code and facilitate manual qa processes this continuous application of quality control aims to improve the quality of software and to reduce the time taken to deliver it by replacing the traditional practice of applying quality control after completing all development this is very similar to the original idea of integrating more frequently to make integration easier only applied to qa processes in the same vein the practice of continuous delivery further extends ci by making sure the software checked in on the mainline is always in a state that can be deployed to users and makes the actual deployment process very rapid workflow when embarking on a change a developer takes a copy of the current code base on which to work as other developers submit changed code to the source code repository this copy gradually ceases to reflect the repository code not only can the existing code base change but new code can be added as well as new libraries and other resources that create dependencies and potential conflicts the longer a branch of code remains checked out the greater the risk of multiple integration conflicts and failures when the developer branch is reintegrated into the main line when developers submit code to the repository they must first update their code to reflect the changes in the repository since they took their copy the more changes the repository contains the more work developers must do before submitting their own changes eventually the repository may become so different from the developers baselines that they enter what is sometimes referred to as merge hell or integration hell where the time it takes to integrate exceeds the time it took to make their original changes continuous integration involves integrating early and often so as to avoid the pitfalls of integration hell the practice aims to reduce rework and thus reduce cost and time a complementary practice to ci is that before submitting work each programmer must do a complete build and run and pass all unit tests integration tests are usually run automatically on a ci server when it detects a new commit history this section needs expansion you can help by adding to it august 2014 the earliest known work on continuous integration was the infuse environment developed by ge kaiser de perry and wm schell in 1994 grady booch used the phrase continuous integration in objectoriented analysis and design with applications 2nd edition to explain how when developing using micro processes internal releases represent a sort of continuous integration of the system and exist to force closure of the micro process in 1997 kent beck and ron jeffries invented extreme programming xp while on the chrysler comprehensive compensation system project including continuous integration was released in 2001 common practices this section contains instructions advice or howto content the purpose of wikipedia is to present facts not to train please help improve this article either by rewriting the howto content or by moving it to wikiversity wikibooks or wikivoyage may 2015 this section lists best practices suggested by various authors on how to achieve continuous integration and how to automate this practice build automation is a best practice itself continuous integration the practice of frequently integrating ones new or changed code with the existing code repository should occur frequently enough that no intervening window remains between commit and build and such that no errors can arise without developers noticing them and correcting them immediately in this way the commit events are debounced to prevent unnecessary builds between a series of rapidfire commits many automated tools offer this scheduling automatically another factor is the need for a version control system that supports atomic commits ie all of a developers changes may be seen as a single commit operation there is no point in trying to build from only half of the changed files to achieve these objectives continuous integration relies on the following principles maintain a code repository version control this practice advocates the use of a revision control system for the projects source code all artifacts required to build the project should be placed in the repository in this practice and in the revision control community the convention is that the system should be buildable from a fresh checkout and not require additional dependencies extreme programming advocate martin fowler also mentions that where branching is supported by tools its use should be minimised instead it is preferred for changes to be integrated rather than for multiple versions of the software to be maintained simultaneously the mainline or trunk should be the place for the working version of the software automate the build build automation a single command should have the capability of building the system many build tools such as make have existed for many years other more recent tools are frequently used in continuous integration environments automation of the build should include automating the integration which often includes deployment into a productionlike environment in many cases the build script not only compiles binaries but also generates documentation website pages statistics and distribution media such as debian deb red hat rpm or windows msi files make the build selftesting once the code is built all tests should run to confirm that it behaves as the developers expect it to behave everyone commits to the baseline every day by committing regularly every committer can reduce the number of conflicting changes checking in a weeks worth of work runs the risk of conflicting with other features and can be very difficult to resolve early small conflicts in an area of the system cause team members to communicate about the change they are making these are lower bounds the typical frequency is expected to be much higher every commit to baseline should be built the system should build commits to the current working version to verify that they integrate correctly a common practice is to use automated continuous integration although this may be done manually for many continuous integration is synonymous with using automated continuous integration where a continuous integration server or daemon monitors the revision control system for changes then automatically runs the build process keep the build fast the build needs to complete rapidly so that if there is a problem with integration it is quickly identified test in a clone of the production environment test environment having a test environment can lead to failures in tested systems when they deploy in the production environment because the production environment may differ from the test environment in a significant way however building a replica of a production environment is cost prohibitive instead the test environment or a separate preproduction environment staging should be built to be a scalable version of the actual production environment to both alleviate costs while maintaining technology stack composition and nuances within these test environments service virtualization is commonly used to obtain ondemand access to dependencies eg apis thirdparty applications services mainframes etc that are beyond the teams control still evolving or too complex to configure in a virtual test lab make it easy to get the latest deliverables making builds readily available to stakeholders and testers can reduce the amount of rework necessary when rebuilding a feature that doesnt meet requirements additionally early testing reduces the chances that defects survive until deployment finding errors earlier also in some cases reduces the amount of work necessary to resolve them all programmers should start the day by updating the project from the repository that way they will all stay up to date everyone can see the results of the latest build it should be easy to find out whether the build breaks and if so who made the relevant change and what that change was automate deployment most ci systems allow the running of scripts after a build finishes in most situations it is possible to write a script to deploy the application to a live test server that everyone can look at a further advance in this way of thinking is continuous deployment which calls for the software to be deployed directly into production often with additional automation to prevent defects or regressions costs and benefits the neutrality of this section is disputed relevant discussion may be found on the talk page please do not remove this message until conditions to do so are met may 2016 learn how and when to remove this template message this section needs additional citations for verification please help improve this article by adding citations to reliable sources unsourced material may be challenged and removed may 2016 learn how and when to remove this template message continuous integration is intended to produce benefits such as integration bugs are detected early and are easy to track down due to small change sets this saves both time and money over the lifespan of a project avoids lastminute chaos at release dates when everyone tries to check in their slightly incompatible versions when unit tests fail or a bug emerges if developers need to revert the codebase to a bugfree state without debugging only a small number of changes are lost because integration happens frequently constant availability of a current build for testing demo or release purposes frequent code checkin pushes developers to create modular less complex code with continuous automated testing benefits can include enforces discipline of frequent automated testing immediate feedback on systemwide impact of local changes software metrics generated from automated testing and ci such as metrics for code coverage code complexity and feature completeness focus developers on developing functional quality code and help develop momentum in a team some downsides of continuous integration can include constructing an automated test suite requires a considerable amount of work including ongoing effort to cover new features and follow intentional code modifications testing is considered a best practice for software development in its own right regardless of whether or not continuous integration is employed and automation is an integral part of project methodologies like testdriven development continuous integration can be performed without any test suite but the cost of quality assurance to produce a releasable product can be high if it must be done manually and frequently there is some work involved to set up a build system and it can become complex making it difficult to modify flexibly however there are a number of continuous integration software projects both proprietary and opensource which can be used continuous integration is not necessarily valuable if the scope of the project is small or contains untestable legacy code value added depends on the quality of tests and how testable the code really is larger teams means that new code is constantly added to the integration queue so tracking deliveries while preserving quality is difficult and builds queueing up can slow down everyone with multiple commits and merges a day partial code for a feature could easily be pushed and therefore integration tests will fail until the feature is complete safety and missioncritical development assurance eg do178c iso 26262 require rigorous documentation and inprocess review that are difficult to achieve using continuous integration this type of life cycle often requires additional steps be completed prior to product release when regulatory approval of the product is required application release automation build light indicator comparison of continuous integration software continuous design continuous testing jenkins multistage continuous integration rapid application development duvall paul m 2007 continuous integration improving software quality and reducing risk addisonwesley isbn9780321336385 fowler martin continuous integration continuous integration wiki a collegial discussion c2 richardson jared continuous integration the cornerstone of a great shop introduction flowers jay a recipe for build maintainability and reusability duvall paul 20071204 developer works version lifecycle mediawiki continuous integration in the cloud pdf crosstalk 2016 bugayenko yegor why continuous integration doesnt work 