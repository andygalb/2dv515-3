procedural programming this article is about the computer programming paradigm for the method of algorithmic content creation see procedural generation programming paradigms action agentoriented arrayoriented automatabased concurrent computing relativistic programming datadriven declarative contrast imperative functional functional logic purely functional logic abductive logic answer set concurrent logic functional logic inductive logic constraint constraint logic concurrent constraint logic dataflow flowbased reactive dynamicscripting eventdriven functionlevel contrast valuelevel pointfree style concatenative generic imperative contrast declarative procedural objectoriented literate languageoriented naturallanguage programming disciplinespecific domainspecific grammaroriented intentional metaprogramming automatic inductive programming reflective attributeoriented macro template nonstructured contrast structured array nondeterministic parallel computing processoriented probabilistic stackbased structured contrast nonstructured blockstructured objectoriented actorbased classbased concurrent prototypebased by separation of concerns aspectoriented roleoriented subjectoriented recursive symbolic valuelevel contrast functionlevel quantum programming vte procedural programming is a programming paradigm derived from structured programming based upon the concept of the procedure call procedures also known as routines subroutines or functions simply contain a series of computational steps to be carried out any given procedure might be called at any point during a programs execution including by other procedures or itself the first major procedural programming languages first appeared circa 1960 including fortran algol cobol and basic pascal and c were published closer to the 1970s computer processors provide hardware support for procedural programming through a stack register and instructions for calling procedures and returning from them hardware support for other types of programming is possible but no attempt was commercially successful for example lisp machines or java processors procedures and modularity modular programming modularity is generally desirable especially in large complicated programs inputs are usually specified syntactically in the form of arguments and the outputs delivered as return values scoping is another technique that helps keep procedures modular it prevents the procedure from accessing the variables of other procedures and vice versa including previous instances of itself without explicit authorization less modular procedures often used in small or quickly written programs tend to interact with a large number of variables in the execution environment which other procedures might also modify because of the ability to specify a simple interface to be selfcontained and to be reused procedures are a convenient vehicle for making pieces of code written by different people or different groups including through programming libraries comparison with other programming paradigms imperative programming procedural programming languages are also imperative languages because they make explicit references to the state of the execution environment this could be anything from variables which may correspond to processor registers to something like the position of the turtle in the logo programming language often the terms procedural programming and imperative programming are used synonymously however procedural programming relies heavily on blocks and scope whereas imperative programming as a whole may or may not have such features as such procedural languages generally use reserved words that act on blocks such as if while and for to implement control flow whereas nonstructured imperative languages use goto statements and branch tables for the same purpose objectoriented programming the focus of procedural programming is to break down a programming task into a collection of variables data structures and subroutines whereas in objectoriented programming it is to break down a programming task into objects that expose behavior methods and data members or attributes using interfaces the most important distinction is that while procedural programming uses procedures to operate on data structures objectoriented programming bundles the two together so an object which is an instance of a class operates on its own data structure the first major objectoriented programming language built from the ground up is java in 1995 nomenclature varies between the two although they have similar semantics procedural objectoriented procedure method record object module class procedure call message functional programming the principles of modularity and code reuse in practical functional languages are fundamentally the same as in procedural languages since they both stem from structured programming so for example procedures correspond to functions both allow the reuse of the same code in various parts of the programs and at various points of its execution by the same token procedure calls correspond to function application functions and their invocations are modularly separated from each other in the same manner by the use of function arguments return values and variable scopes the main difference between the styles is that functional programming languages remove or at least deemphasize the imperative elements of procedural programming the feature set of functional languages is therefore designed to support writing programs as much as possible in terms of pure functions whereas procedural languages model execution of the program as a sequence of imperative commands that may implicitly alter shared state functional programming languages model execution as the evaluation of complex expressions that only depend on each other in terms of arguments and return values for this reason functional programs can have a free order of code execution and the languages may offer little control over the order in which various parts of the program are executed for example the arguments to a procedure invocation in scheme are executed in an arbitrary order functional programming languages support and heavily use firstclass functions anonymous functions and closures although these concepts are being included in newer procedural languages functional programming languages tend to rely on tail call optimization and higherorder functions instead of imperative looping constructs many functional languages however are in fact impurely functional and offer imperativeprocedural constructs that allow the programmer to write programs in procedural style or in a combination of both styles it is common for inputoutput code in functional languages to be written in a procedural style there do exist a few esoteric functional languages like unlambda that eschew structured programming precepts for the sake of being difficult to program in and therefore challenging these languages are the exception to the common ground between procedural and functional languages logic programming in logic programming a program is a set of premises and computation is performed by attempting to prove candidate theorems from this point of view logic programs are declarative focusing on what the problem is rather than on how to solve it however the backward reasoning technique implemented by sld resolution used to solve problems in logic programming languages such as prolog treats programs as goalreduction procedures thus clauses of the form h b1 bn have a dual interpretation both as procedures to showsolve h showsolve b1 and and bn and as logical implications b1 and and bn implies h experienced logic programmers use the procedural interpretation to write programs that are effective and efficient and they use the declarative interpretation to help ensure that programs are correct comparison of programming paradigms declarative programming functional programming contrast imperative programming logic programming objectoriented programming programming paradigms programming language structured programming sql procedural extensions procedural languages at curlie vtetypes of programming languages actorbased array aspectoriented classbased concatenative concurrent dataflow declarative domainspecific dynamic esoteric eventdriven extensible functional imperative logic macro metaprogramming multiparadigm objectbased objectoriented pipeline procedural prototypebased reflective rulebased scripting stack based synchronous templating assembly compiled interpreted machine lowlevel highlevel very highlevel first generation second generation third generation fourth generation fifth generation nonenglishbased visual 