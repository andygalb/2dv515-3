iterative and incremental development iterative and incremental development is any combination of both iterative design or iterative method and incremental build model for development the usage of the term began in software development where the combination of the two terms iterative and incremental has been long standing mentions in section 412 during software development more than one iteration of the software development cycle may be in progress at the same time and this process may be described as an evolutionary acquisition or incremental build approach in software the relationship between iterations and increments is determined by the overall software development methodology and software development process software development core activities processes requirements design engineering construction testing debugging deployment maintenance paradigms and models agile cleanroom incremental prototyping spiral v model waterfall methodologies and frameworks asd devops dad dsdm fdd iid kanban lean sd less mdd msf psp rad rup safe scrum semat tsp up xp supporting disciplines configuration management documentation software quality assurance sqa project management user experience practices atdd bdd cco ci cd ddd pp standup tdd tools compiler debugger profiler gui designer modeling ide build automation release automation infrastructure as code testing standards and bodies of knowledge babok cmmi ieee standards iso 9001 isoiec standards pmbok swebok itil glossaries artificial intelligence computer science electrical and electronics engineering vte iterative development model overview iterative development was created as a response to inefficiencies and problems found in the waterfall model a simplified version of a typical iteration cycle in agile project managementthe basic idea behind this method is to develop a system through repeated cycles iterative and in smaller portions at a time incremental allowing software developers to take advantage of what was learned during development of earlier parts or versions of the system learning comes from both the development and use of the system where possible key steps in the process start with a simple implementation of a subset of the software requirements and iteratively enhance the evolving versions until the full system is implemented at each iteration design modifications are made and new functional capabilities are added the procedure itself consists of the initialization step the iteration step and the project control list the initialization step creates a base version of the system the goal for this initial implementation is to create a product to which the user can react it should offer a sampling of the key aspects of the problem and provide a solution that is simple enough to understand and implement easily to guide the iteration process a project control list is created that contains a record of all tasks that need to be performed it includes items such as new features to be implemented and areas of redesign of the existing solution the control list is constantly being revised as a result of the analysis phase the iteration involves the redesign and implementation of iteration is to be simple straightforward and modular supporting redesign at that stage or as a task added to the project control list the level of design detail is not dictated by the iterative approach in a lightweight iterative project the code may represent the major source of documentation of the system however in a critical iterative project a formal software design document may be used the analysis of an iteration is based upon user feedback and the program analysis facilities available it involves analysis of the structure modularity usability reliability efficiency achievement of goals the project control list is modified in light of the analysis results iterative development phases incremental development slices the system functionality into increments portions in each increment a slice of functionality is delivered through crossdiscipline work from the requirements to the deployment the unified process groups incrementsiterations into phases inception elaboration construction and transition inception identifies project scope requirements functional and nonfunctional and risks at a high level but in enough detail that work can be estimated elaboration delivers a working architecture that mitigates the top risks and fulfills the nonfunctional requirements construction incrementally fillsin the architecture with productionready code produced from analysis design implementation and testing of the functional requirements transition delivers the system into the production operating environment each of the phases may be divided into 1 or more iterations which are usually timeboxed rather than featureboxed architects and analysts work one iteration ahead of developers and testers to keep their workproduct backlog full usagehistory many examples of early usage are provided in craig larman and victor basilis article iterative and incremental development a brief history with one of the earliest being nasas 1960s project mercury some of those mercury engineers later formed a new division within ibm where another early and striking example of a major iid success some organizations such as the us department of defense have a preference for iterative methodologies starting with milstd498 clearly encouraging evolutionary acquisition and iid the dod instruction 50002 released in 2000 stated a clear preference for iid there are two approaches evolutionary and single step contrast with waterfall development programming paradigms action agentoriented arrayoriented automatabased concurrent computing relativistic programming datadriven declarative contrast imperative functional functional logic purely functional logic abductive logic answer set concurrent logic functional logic inductive logic constraint constraint logic concurrent constraint logic dataflow flowbased reactive dynamicscripting eventdriven functionlevel contrast valuelevel pointfree style concatenative generic imperative contrast declarative procedural objectoriented literate languageoriented naturallanguage programming disciplinespecific domainspecific grammaroriented intentional metaprogramming automatic inductive programming reflective attributeoriented macro template nonstructured contrast structured array nondeterministic parallel computing processoriented probabilistic stackbased structured contrast nonstructured blockstructured objectoriented actorbased classbased concurrent prototypebased by separation of concerns aspectoriented roleoriented subjectoriented recursive symbolic valuelevel contrast functionlevel quantum programming vte the main cause due to which most of the software development projects fail is the choice of the model hence it should be made with a great concern for example the waterfall development paradigm completes the projectwide workproducts of each discipline in one step before moving on to the next discipline in the next step business value is delivered all at once and only at the very end of the project whereas backtracking user involvement in waterfall model the user is involved in one stage of the model ie requirement whereas in the incremental model the client is involved at each and every stage variability the software is delivered to the user only after all the stages of life cycle is completed on the other hand every increment is delivered to the user and after the approval of user the developer is allowed to move towards the next module human resources in incremental model less staff is required as compared to waterfall model time limitation operational quality portion is delivered after months while in the incremental model the operational product is given to the user within a few weeks project size waterfall model is unsuitable for small projects while incremental model is best suitable for small as well as large projects implementation guidelines guidelines that drive software implementation and analysis include any difficulty in design coding and testing a modification should signal the need for redesign or recoding modifications should fit easily into isolated and easytofind modules if they do not some redesign is possibly needed modifications to tables should be especially easy to make if any table modification is not quickly and easily done redesign is indicated modifications should become easier to make as the iterations progress if they are not there is a basic problem such as a design flaw or a proliferation of patches patches should normally be allowed to exist for only one or two iterations patches may be necessary to avoid redesigning during an implementation phase the existing implementation should be analyzed frequently to determine how well it measures up to project goals program analysis facilities should be used whenever available to aid in the analysis of partial implementations user reaction should be solicited and analyzed for indications of deficiencies in the current implementation use in hardware and embedded systems while the term iterative and incremental development got started in the software industry many hardware and embedded software development efforts are using iterative and incremental techniques examples of this may be seen in a number of industries one sector that has recently been substantially affected by this shift of thinking has been the space launch industry with substantial new competitive forces at work brought about by faster and more extensive technology innovation brought to bear by the formation of private companies pursuing space launch these companies such as spacex spacex has been explicit about its effort to bring iterative design practices into the space industry and uses the technique on spacecraft launch vehicles electronics and avionics and operational flight hardware operations as the industry has begun to change other launch competitors are beginning to change their longterm development practices with government agencies as well for example the large us launch service provider united launch alliance ula began in 2015 a decadelong project to restructure its launch businessreducing two launch vehicles to oneusing an iterative and incremental approach to get to a partiallyreusable and much lowercost launch system over the next decade adaptive management continuous integration devops incremental adoption dynamic systems development method goaldriven software development process interaction design kaizen microsoft solutions framework objectoriented analysis and design openupbasic pdca rapid application development notes dr alistair cockburn may 2008 using both incremental and iterative development pdf stsc crosstalk usaf software technology support center 21 5 27ndash 30 issn21601593 retrieved 20110720 craig larman victor r basili june 2003 iterative and incremental development a brief history pdf ieee computer ieee computer society 36 6 47ndash 56 doi101109mc20031204375 issn00189162 retrieved 20090110 vtesoftware engineeringfields computer programming requirements engineering software deployment software design software maintenance software testing systems analysis formal methods concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software archaeology software architecture software configuration management software development methodology software development process software quality software quality assurance software verification and validation structured analysis orientations agile aspectoriented object orientation ontology service orientation sdlc modelsdevelopmental agile eup executable uml incremental model iterative model prototype model rad up scrum spiral model vmodel waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml usl sysml softwareengineers victor basili kent beck grady booch fred brooks barry boehm peter chen danese cooper ward cunningham tom demarco edsger w dijkstra delores m etter martin fowler adele goldstine margaret hamilton c a r hoare lois haibt mary jean harrold grace hopper watts humphrey michael a jackson ivar jacobson alan kay nancy leveson stephen j mellor bertrand meyer david parnas trygve reenskaug winston w royce james rumbaugh mary shaw peri tarr elaine weyuker niklaus wirth edward yourdon related fields computer science computer engineering project management risk management systems engineering category commons 