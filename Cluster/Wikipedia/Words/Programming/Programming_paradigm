programming paradigm this article is about classification of programming languages for definition of the term programming model see programming model for the use of the term in project management methodology see software development programming paradigm programming paradigms action agentoriented arrayoriented automatabased concurrent computing relativistic programming datadriven declarative contrast imperative functional functional logic purely functional logic abductive logic answer set concurrent logic functional logic inductive logic constraint constraint logic concurrent constraint logic dataflow flowbased reactive dynamicscripting eventdriven functionlevel contrast valuelevel pointfree style concatenative generic imperative contrast declarative procedural objectoriented literate languageoriented naturallanguage programming disciplinespecific domainspecific grammaroriented intentional metaprogramming automatic inductive programming reflective attributeoriented macro template nonstructured contrast structured array nondeterministic parallel computing processoriented probabilistic stackbased structured contrast nonstructured blockstructured objectoriented actorbased classbased concurrent prototypebased by separation of concerns aspectoriented roleoriented subjectoriented recursive symbolic valuelevel contrast functionlevel quantum programming vte programming paradigms are a way to classify programming languages based on their features languages can be classified into multiple paradigms some paradigms are concerned mainly with implications for the execution model of the language such as allowing side effects or whether the sequence of operations is defined by the execution model other paradigms are concerned mainly with the way that code is organized such as grouping a code into units along with the state that is modified by the code yet others are concerned mainly with the style of syntax and grammar common programming paradigms include imperative in which the programmer instructs the machine how to change its state procedural which groups instructions into procedures objectoriented which groups instructions together with the part of the state they operate on declarative in which the programmer merely declares properties of the desired result but not how to compute it functional in which the desired result is declared as the value of a series of function applications logic in which the desired result is declared as the answer to a question about a system of facts and rules mathematical in which the desired result is declared as the solution of an optimization problem symbolic techniques such as reflection which allow the program to refer to itself might also be considered as a programming paradigm however this is compatible with the major paradigms and thus is not a real paradigm in its own right for example languages that fall into the imperative paradigm have two main features they state the order in which operations occur with constructs that explicitly control that order and they allow side effects in which state can be modified at one point in time within one unit of code and then later read at a different point in time inside a different unit of code the communication between the units of code is not explicit meanwhile in objectoriented programming code is organized into objects that contain state that is only modified by the code that is part of the object most objectoriented languages are also imperative languages in contrast languages that fit the declarative paradigm do not state the order in which to execute operations instead they supply a number of operations that are available in the system along with the conditions under which each is allowed to execute the implementation of the languages execution model tracks which operations are free to execute and chooses the order on its own more at comparison of multiparadigm programming languages overview overview of the various programming paradigms according to peter van roy just as software engineering as a process is defined by differing methodologies so the programming languages as models of computation are defined by differing paradigms some languages are designed to support one paradigm smalltalk supports objectoriented programming haskell supports functional programming while other programming languages support multiple paradigms such as object pascal c java c scala visual basic common lisp scheme perl php python ruby oz and f for example programs written in c object pascal or php can be purely procedural purely objectoriented or can contain elements of both or other paradigms software designers and programmers decide how to use those paradigm elements in objectoriented programming programs are treated as a set of interacting objects in functional programming programs are treated as a sequence of stateless function evaluations when programming computers or systems with many processors in processoriented programming programs are treated as sets of concurrent processes acting on logically shared data structures many programming paradigms are as well known for the techniques they forbid as for those they enable for instance pure functional programming disallows use of sideeffects while structured programming disallows use of the goto statement partly for this reason new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles yet avoiding certain techniques can make it easier to understand program behavior and to prove theorems about program correctness programming paradigms can also be compared with programming models which allow invoking an execution model by using only an api programming models can also be classified into paradigms based on features of the execution model for parallel computing using a programming model instead of a language is common the reason is that details of the parallel hardware leak into the abstractions used to program the hardware this causes the programmer to have to map patterns in the algorithm onto patterns in the execution model which have been inserted due to leakage of hardware into the abstraction as a consequence no one parallel programming language maps well to all computation problems it is thus more convenient to use a base sequential language and insert api calls to parallel execution models via a programming model such parallel programming models can be classified according to abstractions that reflect the hardware such as shared memory distributed memory with message passing notions of place visible in the code and so forth these can be considered flavors of programming paradigm that apply to only parallel languages and programming models criticism some programming language researchers criticise the notion of paradigms as a classification of programming languages eg harper they argue that many programming languages cannot be strictly classified into one paradigm but rather include features from several paradigms see comparison of multiparadigm programming languages history different approaches to programming have developed over time being identified as such either at the time or retrospectively an early approach consciously identified as such is structured programming advocated since the mid 1960s the concept of a programming paradigm as such dates at least to 1978 in the turing award lecture of robert w floyd entitled the paradigms of programming which cites the notion of paradigm as used by thomas kuhn in his the structure of scientific revolutions 1962 machine code the lowestlevel programming paradigms are machine code which directly represents the instructions the contents of program memory as a sequence of numbers and assembly language where the machine instructions are represented by mnemonics and memory addresses can be given symbolic labels these are sometimes called first and secondgeneration languages in the 1960s assembly languages were developed to support library copy and quite sophisticated conditional macro generation and preprocessing abilities call to subroutines external variables and common sections globals enabling significant code reuse and isolation from hardware specifics via use of logical operators such as readwritegetput assembly was and still is used for time critical systems and often in embedded systems as it gives the most direct control of what the machine does procedural languages the next advance was the development of procedural languages these thirdgeneration languages the first described as highlevel languages use vocabulary related to the problem being solved for example common business oriented language cobol uses terms like file move and copy formula translation fortran using mathematical language terminology it was developed mainly for scientific and engineering problems algorithmic language algol focused on being an appropriate language to define algorithms while using mathematical language terminology and targeting scientific and engineering problems just like fortran programming language one pli a hybrid commercialscientific general purpose language supporting pointers beginners all purpose symbolic instruction code basic it was developed to enable more people to write programs c a generalpurpose programming language initially developed by dennis ritchie between 1969 and 1973 at att bell labs all these languages follow the procedural paradigm that is they describe step by step exactly the procedure that should according to the particular programmer at least be followed to solve a specific problem the efficacy and efficiency of any such solution are both therefore entirely subjective and highly dependent on that programmers experience inventiveness and ability objectoriented programming objectoriented programming following the widespread use of procedural languages objectoriented programming oop languages were created such as simula smalltalk c c eiffel php and java in these languages data and methods to manipulate it are kept as one unit called an object with perfect encapsulation one of the distinguishing features of oop the only way that another object or user would be able to access the data is via the objects methods thus the inner workings of an object may be changed without affecting any code that uses the object there is still some controversy raised by alexander stepanov richard stallman and other programmers concerning the efficacy of the oop paradigm versus the procedural paradigm the need for every object to have associative methods leads some skeptics to associate oop with software bloat an attempt to resolve this dilemma came through polymorphism because objectoriented programming is considered a paradigm not a language it is possible to create even an objectoriented assembler language high level assembly hla is an example of this that fully supports advanced data types and objectoriented assembly language programming despite its early origins thus differing programming paradigms can be seen rather like motivational memes of their advocates rather than necessarily representing progress from one level to the next precise comparisons of the efficacy of competing paradigms are frequently made more difficult because of new and differing terminology applied to similar entities and processes together with numerous implementation distinctions across languages further paradigms literate programming as a form of imperative programming structures programs as a humancentered web as in a hypertext essay documentation is integral to the program and the program is structured following the logic of prose exposition rather than compiler convenience independent of the imperative branch declarative programming paradigms were developed in these languages the computer is told what the problem is not how to solve the problem the program is structured as a set of properties to find in the expected result not as a procedure to follow given a database or a set of rules the computer tries to find a solution matching all the desired properties an archetype of a declarative language is the fourth generation language sql and the family of functional languages and logic programming functional programming is a subset of declarative programming programs written using this paradigm use functions blocks of code intended to behave like mathematical functions functional languages discourage changes in the value of variables through assignment making a great deal of use of recursion instead the logic programming paradigm views computation as automated reasoning over a body of knowledge facts about the problem domain are expressed as logic formulas and programs are executed by applying inference rules over them until an answer to the problem is found or the set of formulas is proved inconsistent symbolic programming is a paradigm that describes programs able to manipulate formulas and program components as data support for multiple paradigms see also comparison of multiparadigm programming languages most programming languages support more than one programming paradigm to allow programmers to use the most suitable programming style and associated language constructs for a given job computer programming portal architecture description language comparison of programming languages comparison of programming paradigms domainspecific language mindset modeling language programming domain type system turing completeness von neumann programming languages wikimedia commons has media related to programming paradigms classification of the principal programming paradigms how programming paradigms evolve and get adopted software engineering vtetypes of omputer languagetypes architecture description configuration data exchange hardware description knowledge representation markup modeling programming language query shading specification stylesheet transformation see also categorylists of computer languages categorylists of programming languages list of programming languages by type vtesoftware engineeringfields computer programming requirements engineering software deployment software design software maintenance software testing systems analysis formal methods concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software archaeology software architecture software configuration management software development methodology software development process software quality software quality assurance software verification and validation structured analysis orientations agile aspectoriented object orientation ontology service orientation sdlc modelsdevelopmental agile eup executable uml incremental model iterative model prototype model rad up scrum spiral model vmodel waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml usl sysml softwareengineers victor basili kent beck grady booch fred brooks barry boehm peter chen danese cooper ward cunningham tom demarco edsger w dijkstra delores m etter martin fowler adele goldstine margaret hamilton c a r hoare lois haibt mary jean harrold grace hopper watts humphrey michael a jackson ivar jacobson alan kay nancy leveson stephen j mellor bertrand meyer david parnas trygve reenskaug winston w royce james rumbaugh mary shaw peri tarr elaine weyuker niklaus wirth edward yourdon related fields computer science computer engineering project management risk management systems engineering category commons vtemajor fields of computer sciencenote this template roughly follows the 2012 acm computing classification systemhardware printed circuit board peripheral integrated circuit very large scale integration systems on chip socs energy consumption green computing electronic design automation hardware acceleration computer systemsorganization computer architecture embedded system realtime computing dependability networks network architecture network protocol network components network scheduler network performance evaluation network service software organization interpreter middleware virtual machine operating system software quality software notationsand tools programming paradigm programming language compiler domainspecific language modeling language software framework integrated development environment software configuration management software library software repository software development software development process requirements analysis software design software construction software deployment software maintenance programming team opensource model theory of computation model of computation formal language automata theory computational complexity theory logic semantics algorithms algorithm design analysis of algorithms algorithmic efficiency randomized algorithm computational geometry mathematicsof computing discrete mathematics probability statistics mathematical software information theory mathematical analysis numerical analysis informationsystems database management system information storage systems enterprise information system social information systems geographic information system decision support system process control system multimedia information system data mining digital library computing platform digital marketing world wide web information retrieval security cryptography formal methods security services intrusion detection system hardware security network security information security application security humancomputerinteraction interaction design social computing ubiquitous computing visualization accessibility concurrency concurrent computing parallel computing distributed computing multithreading multiprocessing artificialintelligence natural language processing knowledge representation and reasoning computer vision automated planning and scheduling search methodology control method philosophy of artificial intelligence distributed artificial intelligence machine learning supervised learning unsupervised learning reinforcement learning multitask learning crossvalidation graphics animation rendering image manipulation graphics processing unit mixed reality virtual reality image compression solid modeling appliedcomputing ecommerce enterprise software computational mathematics computational physics computational chemistry computational biology computational social science computational engineering computational healthcare digital art electronic publishing cyberwarfare electronic voting video games word processing operations research educational technology document management book category portal wikiproject commons programming vteprogramming language generations 1gl 2gl 3gl 4gl 5gl vteprogramming languages comparison timeline history apl assembly basic c c c cobol fortran go groovy haskell java javascript js kotlin lisp lua objectivec pascal perl php python ruby rust shell smalltalk swift visual basic net vbnet more category lists alphabetical categorical generational nonenglishbased vtetypes of programming languages actorbased array aspectoriented classbased concatenative concurrent dataflow declarative domainspecific dynamic esoteric eventdriven extensible functional imperative logic macro metaprogramming multiparadigm objectbased objectoriented pipeline procedural prototypebased reflective rulebased scripting stack based synchronous templating assembly compiled interpreted machine lowlevel highlevel very highlevel first generation second generation third generation fourth generation fifth generation nonenglishbased visual vtemajor fields of computer sciencenote this template roughly follows the 2012 acm computing classification systemhardware printed circuit board peripheral integrated circuit very large scale integration systems on chip socs energy consumption green computing electronic design automation hardware acceleration computer systemsorganization computer architecture embedded system realtime computing dependability networks network architecture network protocol network components network scheduler network performance evaluation network service software organization interpreter middleware virtual machine operating system software quality software notationsand tools programming paradigm programming language compiler domainspecific language modeling language software framework integrated development environment software configuration management software library software repository software development software development process requirements analysis software design software construction software deployment software maintenance programming team opensource model theory of computation model of computation formal language automata theory computational complexity theory logic semantics algorithms algorithm design analysis of algorithms algorithmic efficiency randomized algorithm computational geometry mathematicsof computing discrete mathematics probability statistics mathematical software information theory mathematical analysis numerical analysis informationsystems database management system information storage systems enterprise information system social information systems geographic information system decision support system process control system multimedia information system data mining digital library computing platform digital marketing world wide web information retrieval security cryptography formal methods security services intrusion detection system hardware security network security information security application security humancomputerinteraction interaction design social computing ubiquitous computing visualization accessibility concurrency concurrent computing parallel computing distributed computing multithreading multiprocessing artificialintelligence natural language processing knowledge representation and reasoning computer vision automated planning and scheduling search methodology control method philosophy of artificial intelligence distributed artificial intelligence machine learning supervised learning unsupervised learning reinforcement learning multitask learning crossvalidation graphics animation rendering image manipulation graphics processing unit mixed reality virtual reality image compression solid modeling appliedcomputing ecommerce enterprise software computational mathematics computational physics computational chemistry computational biology computational social science computational engineering computational healthcare digital art electronic publishing cyberwarfare electronic voting video games word processing operations research educational technology document management book category portal wikiproject commons authority control gnd 43082245 