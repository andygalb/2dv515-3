comparison of instruction set architectures factors bits computer architectures are often described as nbit architectures today n is often 8 16 32 or 64 but other sizes have been used this is actually a strong simplification a computer architecture often has a few more or less natural datasizes in the instruction set but the hardware implementation of these may be very different many architectures have instructions operating on half andor twice the size of respective processors major internal datapaths examples of this are the 8080 z80 mc68000 as well as many others on this type of implementations a twice as wide operation typically also takes around twice as many clock cycles which is not the case on high performance implementations on the 68000 for instance this means 8 instead of 4 clock ticks and this particular chip may be described as a 32bit architecture with a 16bit implementation the external databus width is often not useful to determine the width of the architecture the ns32008 ns32016 and ns32032 were basically the same 32bit chip with different external data buses the ns32764 had a 64bit bus but used 32bit registers the width of addresses may or may not be different from the width of data early 32bit microprocessors often had a 24bit address as did the system360 processors operands instruction set number of operands the number of operands is one of the factors that may give an indication about the performance of the instruction set a threeoperand architecture will allow a b c to be computed in one instruction a twooperand architecture will allow a a b to be computed in one instruction so two instructions will need to be executed to simulate a single threeoperand instruction a b a a c endianness an architecture may use big or little endianness or both or be configurable to use either little endian processors order bytes in memory with the least significant byte of a multibyte value in the lowestnumbered memory location big endian architectures instead order them with the most significant byte at the lowestnumbered address the x86 architecture as well as several 8bit architectures are little endian most risc architectures sparc power powerpc mips were originally big endian arm was little endian but many including arm are now configurable endianness only applies to processors that allow individual addressing of units of data such as bytes that are smaller than the basic addressable machine word instruction sets usually the number of registers is a power of two eg 8 16 32 in some cases a hardwiredtozero pseudoregister is included as part of register files of architectures mostly to simplify indexing modes this table only counts the integer registers usable by general instructions at any moment architectures always include specialpurpose registers such as the program pointer pc those are not counted unless mentioned note that some architectures such as sparc have register window for those architectures the count below indicates how many registers are available within a register window also nonarchitected registers for register renaming are not counted note a common type of architecture loadstore is a synonym for register register below meaning no instructions access memory except special load to registers and store from registers with the possible exceptions of atomic memory operations for locking the table below compares basic information about instruction sets to be implemented in the cpu architectures architecture bits version introduced max operands type design registersexcluding fpvector instruction encoding branch evaluation endianness extensions open royaltyfree 6502 8 1975 1 register memory cisc 3 variable 8 to 32bit condition register little 65k 64864 2006 1 memorymemory cisc 1 variable 8bit to 256bytes compare and branch little 68000 680x0 32 1979 2 register memory cisc 8 data and 8 address variable condition register big 8080 8 1974 2 register memory cisc 8 variable 8 to 24bits condition register little 8051 32832 1977 1 registerregister cisc 32 in 4bit16 in 8bit8 in 16bit4 in 32bit variable 8bit to 128bytes compare and branch little 8086 x86 16 32 64163264 1978 2 integer3 avx register memory cisc 8 4 or 6 segment reg 1632bit16 2 segment reg gscs 64bit variable 8086 8 to 48bit condition code little x87 ia32 mmx 3dnow ssesse2 pae x8664 sse3 sse4bmi avx aes fma xop f16c no no alpha 64 1992 3 register register risc 32 including zero fixed 32bit condition register bi mvi bwx fix cix no arc 1632 arcv2 1996 3 register register risc 16 or 32 including sp user can increase to 60 variable 16 and 32bit compare and branch bi apex userdefined instructions arm 3216 armv7 andearlier 1983 3 register register risc 7 in 16bit thumb mode15 in 32bit fixed 32bit thumb fixed 16bit thumb2variable 16 and 32bit condition code bi neon jazelle vfptrustzone lpae no armv8a 6432 armv8a 2011 3 register register risc 32 including the stack pointerzero register fixed 32bit in armv7 compatibility mode thumbfixed 16bit thumb2 variable 16 and 32bit a64 condition code bi none all armv7extensions are nonoptional no avr 8 1997 2 register register risc 3216 on reduced architecture variable mostly 16bit four instructions are 32bit condition registerskip conditionedon an io orgeneral purposeregister bitcompare and skip little avr32 32 rev 2 2006 23 risc 15 variable big java virtual machine blackfin 32 2000 risc 8 little cdc cyber 60 1970s 3 register memory risc 24 8 18bit address reg8 18bit index reg8 60bit operand reg variable 15 30 and 60bit compare and branch na comparemove unit additionalperipheral processing units no no crusoenative vliw 32 2000 1 register register vliw 1 in native push stack mode6 in x86 emulation 8 in x87mmx mode 50 in rename status12 integer 48 shadow 4 debug in native vliwmode variable 64 or 128bit condition code little elbrusnative vliw 64 elbrus4s 2014 1 register register vliw 864 64 condition code little justintime dynamic translation x87 ia32 mmx ssesse2 x8664 sse3 avx no no dlx 32 1990 3 risc 32 fixed 32bit big esirisc 1632 2009 3 register register risc 872 variable 16 or 32bit compare and branchand condition register bi userdefined instructions no no itaniumia64 64 2001 register register epic 128 fixed 128 bit bundles with 5 bit template tagand 3 instructions each 41 bit long condition register biselectable intel virtualization technology no no m32r 32 1997 risc 16 fixed 16 or 32bit bi mico32 32 2006 3 register register risc 32 fixed 32bit compare and branch big userdefined instructions yes yes mips 64 3264 5 1981 13 register register risc 432 including zero fixed 32bit condition register bi mdmx mips3d no mmix 64 1999 3 register register risc 256 fixed 32bit big yes yes ns320xx 32 1982 5 memory memory cisc 8 variable huffman coded up to 23bytes long condition code little bitblt instructions openrisc 32 64 2010 3 register register risc 16 or 32 fixed yes yes parischppa 64 3264 20 1986 3 register register risc 32 fixed 32bit compare and branch big bi max no pdp11 16 19701990 3 memory memory cisc 8 includes stack pointerthough any register canact as stack pointer fixed 16 condition code little floating pointcommercial instruction set no no powerpc 32643264 207 1991 3 register register risc 32 fixed 32bit variable condition code bigbi altivec apu vsx cell yes no riscv 32 64 128 2010 register register risc 32 including zero variable compare and branch little yes yes rx 643216 2000 3 memory memory cisc 4 integer 4 address variable compare and branch little no score 1632 2005 risc little sparc 64 3264 osa2015 1985 3 register register risc 32 including zero fixed 32bit condition code big bi vis yes yes superh sh 32 1990s 2 register registerregister memory risc 16 fixed 16 or 32bit variable condition codesingle bit bi system360system370zarchitecture 64 3264 1964 2 most3 fma distinctoperand facility register memorymemory memoryregister register cisc 16 variable condition code big transputer 32 464 1987 1 stack machine misc 3 as stack variable 8 120 bytes compare and branch little vax 32 1977 6 memory memory cisc 16 variable compare and branch little z80 8 1976 2 register memory cisc 17 variable 8 to 32bits condition register little architecture bits version introduced max operands type design registersexcluding fpvector instruction encoding branch evaluation endianness extensions open royaltyfree computer science portal central processing unit cpu cpu design comparison of cpu microarchitectures instruction set list of instruction sets microprocessor benchmark computing vteprocessor technologiesmodels turing machine universal postturing quantum belt machine stack machine finitestate machine with datapath hierarchical queue automaton register machines counter pointer randomaccess randomaccess stored program architecture von neumann harvard modified dataflow transporttriggered cellular endianness memory access numa huma loadstore registermemory cache hierarchy memory hierarchy virtual memory secondary storage heterogeneous fabric multiprocessing cognitive neuromorphic instruction setarchitecturestypes cisc risc applicationspecific edge trips vliw epic misc oisc nisc zisc comparison addressing modes x86 arm mips power powerpc sparc itanium unicore microblaze riscv othersexecutioninstruction pipelining pipeline stall operand forwarding classic risc pipeline hazards data dependency structural control false sharing outoforder tomasulo algorithm reservation station reorder buffer register renaming speculative branch prediction memory dependence prediction parallelismlevel bit bitserial word instruction pipelining scalar superscalar task thread process data vector memory distributed multithreading temporal simultaneous hyperthreading speculative preemptive cooperative flynns taxonomy sisd simd swar simt misd mimd spmd processorperformance transistor count instructions per cycle ipc cycles per instruction cpi instructions per second ips floatingpoint operations per second flops transactions per second tps synaptic updates per second sups performance per watt ppw cache performance metrics computer performance by orders of magnitude types central processing unit cpu graphics processing unit gpu gpgpu vector barrel stream coprocessor asic fpga cpld multichip module mcm system in package sip by application microprocessor microcontroller mobile notebook ultralowvoltage asip systemson chip systemonchip soc multiprocessor mpsoc programmable psoc networkonchip noc hardwareaccelerators ai accelerator vision processing unit vpu physics processing unit ppu digital signal processor dsp tensor processing unit tpu secure cryptoprocessor network processor baseband processor word size 1bit 2bit 4bit 8bit 16bit 32bit 48bit 64bit 128bit 256bit 512bit others variable core count singlecore multicore manycore heterogeneous architecture components core cache cpu cache replacement policies coherence bus clock rate fifo functional units arithmetic logic unt alu address generation unit agu floatingpoint unit fpu memory management unit loadstore unit translation lookaside buffer tlb logic combinational sequential glue logic gate quantum array registers processor register register file memory buffer program counter stack control unit instruction unit data buffer write buffer microcode rom counter datapath multiplexer demultiplexer adder multiplier cpu binary decoder address decoder sum addressed decoder barrel shifter circuitry integrated circuit 3d mixed signal power management boolean digital analog quantum switch powermanagement pmu apm acpi dynamic frequency scaling dynamic voltage scaling clock gating performance per watt ppw related history of generalpurpose cpus microprocessor chronology processor design digital electronics hardware security module 