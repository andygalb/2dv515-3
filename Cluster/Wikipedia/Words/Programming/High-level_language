high in computer science a highlevel programming language is a programming language with strong abstraction from the details of the computer in contrast to lowlevel programming languages it may use natural language elements be easier to use or may automate or even hide entirely significant areas of computing systems eg memory management making the process of developing a program simpler and more understandable than when using a lowerlevel language the amount of abstraction provided defines how highlevel a programming language is in the 1960s lowlevel programming languages using a compiler were commonly called autocodes examples of autocodes are cobol and fortran the first highlevel programming language designed for computers was plankalkl created by konrad zuse algol also introduced several structured programming concepts such as the whiledo and ifthenelse constructs and its syntax was the first to be described in formal notation backusnaur form bnf during roughly the same period cobol introduced records also called structs and lisp introduced a fully general lambda abstraction in a programming language for the first time features highlevel language refers to the higher level of abstraction from machine language rather than dealing with registers memory addresses and call stacks highlevel languages deal with variables arrays objects complex arithmetic or boolean expressions subroutines and functions loops threads locks and other abstract computer science concepts with a focus on usability over optimal program efficiency unlike lowlevel assembly languages highlevel languages have few if any language elements that translate directly into a machines native opcodes other features such as string handling routines objectoriented language features and file inputoutput may also be present one thing to note about highlevel programming languages is that these languages allow the programmer to be detached and separated from the machine that is unlike lowlevel languages like assembly or machine language highlevel programming can amplify the programmers instructions and trigger a lot of data movements in the background without their knowledge the responsibility and power of executing instructions have been handed over to the machine from the programmer abstraction penalty highlevel languages intend to provide features which standardize common tasks permit rich debugging and maintain architectural agnosticism while lowlevel languages often produce more efficient code through optimization for a specific system architecture abstraction penalty is the border that prevents highlevel programming techniques from being applied in situations where computational limitations standards conformance or physical constraints require access to lowlevel architectural resources fi response times hardware integration highlevel programming exhibits features like more generic data structuresoperations runtime interpretation and intermediate code files which often result in execution of far more operations than necessary higher memory consumption and larger binary program size for this reason code which needs to run particularly quickly and efficiently may require the use of a lowerlevel language even if a higherlevel language would make the coding easier in many cases critical portions of a program mostly in a highlevel language can be handcoded in assembly language leading to a much faster more efficient or simply reliably functioning optimised program however with the growing complexity of modern microprocessor architectures welldesigned compilers for highlevel languages frequently produce code comparable in efficiency to what most lowlevel programmers can produce by hand and the higher abstraction may allow for more powerful techniques providing better overall results than their lowlevel counterparts in particular settings highlevel languages are designed independent of a specific computing system architecture this facilitates executing a program written in such a language on any computing system with compatible support for the interpreted or jit program highlevel languages can be improved as their designers develop improvements in other cases new highlevel languages evolve from one or more others with the goal of aggregating the most popular constructs with new or improved features an example of this is scala which maintains backward compatibility with java which means that programs and libraries written in java will continue to be usable even if a programming shop switches to scala this makes the transition easier and the lifespan of such highlevel coding indefinite in contrast lowlevel programs rarely survive beyond the system architecture which they were written for without major revision this is the engineering tradeoff for the abstraction penalty relative meaning examples of highlevel programming languages in active use today include python visual basic delphi perl php ecmascript ruby c and many others the terms highlevel and lowlevel are inherently relative some decades ago the c language and similar languages were most often considered highlevel as it supported concepts such as expression evaluation parameterised recursive functions and data types and structures while assembly language was considered lowlevel today many programmers might refer to c as lowlevel as it lacks a large runtimesystem no garbage collection etc basically supports only scalar operations and provides direct memory addressing it therefore readily blends with assembly language and the machine level of cpus and microcontrollers assembly language may itself be regarded as a higher level but often still onetoone if used without macros representation of machine code as it supports concepts such as constants and limited expressions sometimes even variables procedures and data structures machine code in its turn is inherently at a slightly higher level than the microcode or microoperations used internally in many processors execution modes this section does not cite any sources october 2018 learn how and when to remove this template message there are three general modes of execution for modern highlevel languages interpreted when code written in a language is interpreted its syntax is read and then executed directly with no compilation stage a program called an interpreter reads each program statement following the program flow then decides what to do and does it a hybrid of an interpreter and a compiler will compile the statement into machine code and execute that the machine code is then discarded to be interpreted anew if the line is executed again interpreters are commonly the simplest implementations of the behavior of a language compared to the other two variants listed here compiled when code written in a language is compiled its syntax is transformed into an executable form before running there are two types of compilation machine code generation some compilers compile source code directly into machine code this is the original mode of compilation and languages that are directly and completely transformed to machinenative code in this way may be called truly compiled languages see assembly language intermediate representations when code written in a language is compiled to an intermediate representation that representation can be optimized or saved for later execution without the need to reread the source file when the intermediate representation is saved it may be in a form such as byte code the intermediate representation must then be interpreted or further compiled to execute it virtual machines that execute byte code directly or transform it further into machine code have blurred the once clear distinction between intermediate representations and truly compiled languages sourcetosource translated or transcompiled code written in a language may be translated into terms of a lowerlevel programming language for which native code compilers are already widely available javascript and the c programming language are common targets for such translators see coffeescript chicken scheme and eiffel as examples specifically the generated c and c code can be seen as generated from the eiffel programming language when using the eiffelstudio ide in the eifgens directory of any compiled eiffel project in eiffel the translated process is referred to as transcompiling or transcompiled and the eiffel compiler as a transcompiler note that languages are not strictly interpreted languages or compiled languages rather implementations of language behavior use interpretation or compilation for example algol 60 and fortran have both been interpreted even though they were more typically compiled similarly java shows the difficulty of trying to apply these labels to languages rather than to implementations java is compiled to bytecode and the bytecode is subsequently executed by either interpretation in a jvm or compilation typically with a justintime compiler such as hotspot again in a jvm moreover compilation transcompiling and interpretation are not strictly limited to just a description of the compiler artifact binary executable or il assembly highlevel language computer architecture alternatively it is possible for a highlevel language to be directly implemented by a computer the computer directly executes the hll code this is known as a highlevel language computer architecture the computer architecture itself is designed to be targeted by a specific highlevel language the burroughs large systems were target machines for algol 60 for example computer programming portal abstraction computer science generational list of programming languages lowlevel programming languages highlevel assembler very highlevel programming languages categorical list of programming languages httpc2comcgiwikihighlevellanguage the wikiwikiwebs article on highlevel programming languages vtetypes of programming languages actorbased array aspectoriented classbased concatenative concurrent dataflow declarative domainspecific dynamic esoteric eventdriven extensible functional imperative logic macro metaprogramming multiparadigm objectbased objectoriented pipeline procedural prototypebased reflective rulebased scripting stack based synchronous templating assembly compiled interpreted machine lowlevel highlevel very highlevel first generation second generation third generation fourth generation fifth generation nonenglishbased visual authority control gnd 41603679 